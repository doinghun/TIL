(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{132:function(e,t,r){"use strict";r.d(t,"a",(function(){return u})),r.d(t,"b",(function(){return f}));var n=r(0),a=r.n(n);function l(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function i(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function s(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?i(Object(r),!0).forEach((function(t){l(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):i(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function o(e,t){if(null==e)return{};var r,n,a=function(e,t){if(null==e)return{};var r,n,a={},l=Object.keys(e);for(n=0;n<l.length;n++)r=l[n],t.indexOf(r)>=0||(a[r]=e[r]);return a}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(n=0;n<l.length;n++)r=l[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(a[r]=e[r])}return a}var c=a.a.createContext({}),b=function(e){var t=a.a.useContext(c),r=t;return e&&(r="function"==typeof e?e(t):s(s({},t),e)),r},u=function(e){var t=b(e.components);return a.a.createElement(c.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.a.createElement(a.a.Fragment,{},t)}},d=a.a.forwardRef((function(e,t){var r=e.components,n=e.mdxType,l=e.originalType,i=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),u=b(r),d=n,f=u["".concat(i,".").concat(d)]||u[d]||p[d]||l;return r?a.a.createElement(f,s(s({ref:t},c),{},{components:r})):a.a.createElement(f,s({ref:t},c))}));function f(e,t){var r=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var l=r.length,i=new Array(l);i[0]=d;var s={};for(var o in t)hasOwnProperty.call(t,o)&&(s[o]=t[o]);s.originalType=e,s.mdxType="string"==typeof e?e:n,i[1]=s;for(var c=2;c<l;c++)i[c]=r[c];return a.a.createElement.apply(null,i)}return a.a.createElement.apply(null,r)}d.displayName="MDXCreateElement"},178:function(e,t,r){"use strict";r.r(t),t.default=r.p+"assets/images/preorder_traversal-6b4b1dcb3d54ff9b755333759b20135f.jpg"},179:function(e,t,r){"use strict";r.r(t),t.default=r.p+"assets/images/inorder_traversal-9fd91510dbfe6a31cdc55f5e5c1d9830.jpg"},180:function(e,t,r){"use strict";r.r(t),t.default=r.p+"assets/images/postorder_traversal-8426d1d437f0ef69fcd12f8417a2498f.jpg"},181:function(e,t,r){"use strict";r.r(t),t.default=r.p+"assets/images/bfs-b2798dcfa6a13ff05df2e3e5056a5b63.png"},87:function(e,t,r){"use strict";r.r(t),r.d(t,"frontMatter",(function(){return s})),r.d(t,"metadata",(function(){return o})),r.d(t,"rightToc",(function(){return c})),r.d(t,"default",(function(){return u}));var n=r(3),a=r(7),l=(r(0),r(132)),i=["components"],s={slug:"ds-binary-tree-traversal",title:"Binary Tree Traversal"},o={unversionedId:"cs/1-data-structure/ds-binary-tree-traversal",id:"cs/1-data-structure/ds-binary-tree-traversal",isDocsHomePage:!1,title:"Binary Tree Traversal",description:"Binary Tree Traversal",source:"@site/docs/cs/1-data-structure/ds-binary-tree-traversal.md",slug:"/cs/1-data-structure/ds-binary-tree-traversal",permalink:"/TIL/docs/cs/1-data-structure/ds-binary-tree-traversal",editUrl:"https://github.com/doinghun/TIL/edit/master/website/docs/cs/1-data-structure/ds-binary-tree-traversal.md",version:"current",lastUpdatedAt:1632925168,sidebar:"cs",next:{title:"Singly Linked List",permalink:"/TIL/docs/cs/1-data-structure/ds-singly-linked-list"}},c=[{value:"Binary Tree Traversal",id:"binary-tree-traversal",children:[{value:"Depth-First Search",id:"depth-first-search",children:[]},{value:"Breadth-First Search",id:"breadth-first-search",children:[]}]}],b={rightToc:c};function u(e){var t=e.components,s=Object(a.a)(e,i);return Object(l.b)("wrapper",Object(n.a)({},b,s,{components:t,mdxType:"MDXLayout"}),Object(l.b)("h2",{id:"binary-tree-traversal"},"Binary Tree Traversal"),Object(l.b)("h3",{id:"depth-first-search"},"Depth-First Search"),Object(l.b)("h4",{id:"pre-order-traversal"},"Pre-order Traversal"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"Pre-order traversal is to visit the root first.\nThen traverse the left subtree.\nFinally, traverse the right subtree.")),Object(l.b)("p",null,Object(l.b)("img",{alt:"Preorder Traversal",src:r(178).default}),Object(l.b)("em",{parentName:"p"},"[ A \u2192 B \u2192 D \u2192 E \u2192 C \u2192 F \u2192 G ]")),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Javascript Solution")),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-javascript"},"var preorderTraversal = function (root) {\n  //corner case\n  if (root == null) return [];\n  //declarations\n  let result = [];\n  let stack = [root];\n  while (stack.length) {\n    //initially, stack.length is 1\n    let pointer = stack.pop(); //node pointer\n    result.push(pointer.val); //insert pointed node at the end of result\n    if (pointer.right) {\n      stack.push(pointer.right); //stack right subtree first\n    }\n    if (pointer.left) {\n      stack.push(pointer.left); //stack left subtree on top of right subtree\n    } //iterate until stack is empty\n  }\n  return result;\n};\n")),Object(l.b)("h4",{id:"in-order-traversal"},"In-order Traversal"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"In-order traversal is to traverse the left subtree first.\nThen visit the root.\nFinally, traverse the right subtree.")),Object(l.b)("p",null,Object(l.b)("img",{alt:"In-order Traversal",src:r(179).default}),Object(l.b)("em",{parentName:"p"},"[D \u2192 B \u2192 E \u2192 A \u2192 F \u2192 C \u2192 G]")),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Javascript Solution")),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-javascript"},"var inorderTraversal = function (root) {\n  //corner case\n  if (root == null) return [];\n  //declaration\n  let result = [];\n  let stack = [];\n  let pointer = root;\n  while (stack.length || pointer) {\n    if (pointer) {\n      //if pointed node is not null\n      stack.push(pointer); //store pointed node at the top of stack\n      pointer = pointer.left; //shift pointer to left node\n    } else {\n      //if pointed node is null (reached the leaf)\n      pointer = stack.pop(); //assign extracted top stack value to pointer\n      result.push(pointer.val); //insert pointed node at the end of result\n      pointer = pointer.right; //shift pointer to right node\n    }\n  }\n  return result;\n};\n")),Object(l.b)("h4",{id:"post-order-traversal"},"Post-order Traversal"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"Post-order traversal is to traverse the left subtree first.\nThen traverse the right subtree.\nFinally, visit the root.")),Object(l.b)("p",null,Object(l.b)("img",{alt:"Post-order Traversal",src:r(180).default}),Object(l.b)("em",{parentName:"p"},"[D \u2192 E \u2192 B \u2192 F \u2192 G \u2192 C \u2192 A]")),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Javascript Solution")),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-javascript"},"var postorderTraversal = function (root) {\n  //corner case\n  if (root == null) return [];\n  //declarations\n  let result = [];\n  let stack = [root];\n  while (stack.length) {\n    let pointer = stack.pop(); //node pointer\n    result.unshift(pointer.val); //insert pointed node at the front of result\n    if (pointer.left) {\n      stack.push(pointer.left); //stack left subtree first\n    }\n    if (pointer.right) {\n      stack.push(pointer.right); //stack right subtree on top of left subtree\n    }\n  }\n  return result;\n};\n")),Object(l.b)("h3",{id:"breadth-first-search"},"Breadth-First Search"),Object(l.b)("p",null,"Level-order traversal is to traverse the tree level by level."),Object(l.b)("p",null,Object(l.b)("inlineCode",{parentName:"p"},"Breadth-First Search")," is an algorithm to traverse or search in data structures like a tree or a graph. The algorithm starts with a root node and visit the node itself first. Then traverse its neighbors, traverse its second level neighbors, traverse its third level neighbors, so on and so forth."),Object(l.b)("p",null,Object(l.b)("img",{alt:"BFS",src:r(181).default})),Object(l.b)("p",null,"ie. Given Binary Tree"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre"},"    3\n   / \\\n  9  20\n    /  \\\n   15   7\n")),Object(l.b)("p",null,"returns"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre"},"[\n  [3],\n  [9,20],\n  [15,7]\n]\n")),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Javascript Solution")),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-javascript"},"var levelOrder = function (root) {\n  if (root == null) return [];\n  let result = [];\n  let queue = [root];\n  while (queue.length) {\n    let size = queue.length;\n    let temp = [];\n    for (i = 0; i < size; i++) {\n      // iterate through # of child nodes\n      let node = queue.shift(); // queue uses shift vs stack uses pop (see Note)\n      temp.push(node.val);\n      if (node.left) {\n        queue.push(node.left); // queue left subtree first\n      }\n      if (node.right) {\n        queue.push(node.right); // queue right subtree after left subtree\n      }\n    }\n    result.push(temp);\n  }\n  return result;\n};\n")),Object(l.b)("table",null,Object(l.b)("thead",{parentName:"table"},Object(l.b)("tr",{parentName:"thead"},Object(l.b)("th",{parentName:"tr",align:null},"After"),Object(l.b)("th",{parentName:"tr",align:null},"queue (before)"),Object(l.b)("th",{parentName:"tr",align:null},"temp"),Object(l.b)("th",{parentName:"tr",align:null},"queue (after)"),Object(l.b)("th",{parentName:"tr",align:null},"result"))),Object(l.b)("tbody",{parentName:"table"},Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"1st Iteration"),Object(l.b)("td",{parentName:"tr",align:null},"[3 \u2192 \u2022\u2022\u2022]"),Object(l.b)("td",{parentName:"tr",align:null},"[ 3 ]"),Object(l.b)("td",{parentName:"tr",align:null},"[9 \u2192 \u2022\u2022\u2022, 20 \u2192 \u2022\u2022\u2022]"),Object(l.b)("td",{parentName:"tr",align:null},"[ ","[3]"," ]")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"2nd Iteration (inner loop)"),Object(l.b)("td",{parentName:"tr",align:null},"[9 \u2192 \u2022\u2022\u2022, 20 \u2192 \u2022\u2022\u2022]"),Object(l.b)("td",{parentName:"tr",align:null},"[ 9 ]"),Object(l.b)("td",{parentName:"tr",align:null},"[20 \u2192 \u2022\u2022\u2022]"),Object(l.b)("td",{parentName:"tr",align:null},"[ ","[3]",", ","[9]"," ]")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"2nd Iteration (inner loop)"),Object(l.b)("td",{parentName:"tr",align:null},"[20 \u2192 \u2022\u2022\u2022]"),Object(l.b)("td",{parentName:"tr",align:null},"[ 9, 20 ]"),Object(l.b)("td",{parentName:"tr",align:null},"[15 \u2192 \u2022\u2022\u2022, 7 \u2192 \u2022\u2022\u2022]"),Object(l.b)("td",{parentName:"tr",align:null},"[ ","[3]",", ","[9,20]"," ]")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"3rd Iteration (inner loop)"),Object(l.b)("td",{parentName:"tr",align:null},"[15 \u2192 \u2022\u2022\u2022, 7 \u2192 \u2022\u2022\u2022]"),Object(l.b)("td",{parentName:"tr",align:null},"[ 15 ]"),Object(l.b)("td",{parentName:"tr",align:null},"[7 \u2192 \u2022\u2022\u2022]"),Object(l.b)("td",{parentName:"tr",align:null},"[ ","[3]",", ","[9,20]",", ","[15]"," ]")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"3rd Iteration (inner loop)"),Object(l.b)("td",{parentName:"tr",align:null},"[7 \u2192 \u2022\u2022\u2022]"),Object(l.b)("td",{parentName:"tr",align:null},"[ 7 ]"),Object(l.b)("td",{parentName:"tr",align:null},"[ ]"),Object(l.b)("td",{parentName:"tr",align:null},"[ ","[3]",", ","[9,20]",", ","[15,7]"," ]")))),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Note:")),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"Stack: LIFO (Last In First Out) ie. Stack of Plates"),Object(l.b)("li",{parentName:"ul"},"Queue: FIFO (First In First Out) ie. Queue in the movie")),Object(l.b)("hr",null),Object(l.b)("p",null,Object(l.b)("em",{parentName:"p"},"References:")),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("em",{parentName:"li"},Object(l.b)("a",{parentName:"em",href:"https://leetcode.com/explore/learn/card/data-structure-tree/134/traverse-a-tree/"},"Question Source - Leetcode"))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("em",{parentName:"li"},Object(l.b)("a",{parentName:"em",href:"https://www.youtube.com/watch?v=wjI1WNcIntg"},"Data Structures: Stacks & Queues"))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("em",{parentName:"li"},Object(l.b)("a",{parentName:"em",href:"https://www.tutorialspoint.com/data_structures_algorithms/tree_traversal.htm"},"Data Structure & Algorightms - Tree Traversal")))))}u.isMDXComponent=!0}}]);